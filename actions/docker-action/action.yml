name: "Docker Build and Publish Composite Action"
description: "Composite action for building and publishing Docker images using Docker Buildx."
inputs:
  ref:
    description: "Branch to create a release from."
    required: false
    default: ""
  custom-image-name:
    description: "Custom name for the Docker image."
    required: false
    default: ""
  context:
    description: "Pipeline context."
    required: false
    default: "git"
  dry-run:
    description: "Run without pushing (dry run)."
    required: false
    default: "false"
  download-artifact:
    description: "Flag to download the artifact."
    required: false
    default: "false"
  component:
    description: "Component configuration in JSON format (an array with a single object)."
    required: false
    default: '[{"name": "default", "file": "./Dockerfile", "context": "."}]'
  platforms:
    description: "Platforms for which the Docker image will be built."
    required: false
    default: "linux/amd64"
  tags:
    description: "Docker image tags. If empty, tags will be generated automatically."
    required: false
    default: ""
  download-artifact-ids:
    description: "IDs of the artifacts to download, comma-separated. Either inputs `artifact-ids` or `name` can be used, but not both. Optional"
    required: false
    default: ""
  download-artifact-path:
    description: "Destination path. Supports basic tilde expansion. Optional. Default is $GITHUB_WORKSPACE"
    required: false
    default: ""
  download-artifact-pattern:
    description: "A glob pattern to the artifacts that should be downloaded. Ignored if name is specified. Optional."
    required: false
    default: ""
  download-artifact-merge-multiple:
    description: "When download multiple artifacts unpack them as is or into separate directories. Optional."
    required: false
    default: "false"
  sbom:
    description: "Flag to enable SBoM generation."
    required: false
    default: "false"
  build-args:
    description: "Build arguments for the Docker image, in JSON format."
    required: false
    default: ""
  security-scan:
    description: "Flag to enable security scanning of the Docker image."
    required: false
    default: "false"
  docker-io-user:
    description: "Docker Hub username for security scanning."
    required: false
    default: ""
  docker-io-password:
    description: "Docker Hub password for security scanning."
    required: false
    default: ""
  checkout:
    description: "Flag to enable repository checkout."
    required: false
    default: "true"
  debug:
    description: "Flag to enable debug mode."
    required: false
    default: "false"
outputs:
  image-name:
    description: "The name of the built Docker image."
    value: "${{ steps.output_result.outputs.image_name }}"
  metadata-json:
    description: "Path to the generated metadata file."
    value: "${{ steps.output_result.outputs.metadata_path }}"
  metadata-filename:
    description: "Name of the generated metadata file."
    value: "${{ steps.output_result.outputs.metadata_filename }}"
runs:
  using: "composite"
  steps:
    - name: Parse Component JSON
      id: parse_component
      shell: bash
      run: |
        # Parse the input JSON object directly
        component='${{ inputs.component }}'
        component_parsed=$(echo "$component" | jq 'if type=="array" then .[0] else . end')
        comp_name=$(echo "$component_parsed" | jq -r '.name')
        comp_file=$(echo "$component_parsed" | jq -r '.file')
        comp_ctx=$(echo "$component_parsed" | jq -r '.context')
        echo "name=$comp_name" >> "$GITHUB_OUTPUT"
        echo "file=$comp_file" >> "$GITHUB_OUTPUT"
        echo "ctx=$comp_ctx" >> "$GITHUB_OUTPUT"

    - name: Prepare Image Name
      shell: bash
      run: |
        if [ -n "${{ inputs.custom-image-name }}" ]; then
            CONTAINER_NAME="${{ inputs.custom-image-name }}"
        elif [ -n "${{ steps.parse_component.outputs.name }}" ] && [ "${{ steps.parse_component.outputs.name }}" != "default" ]; then
           CONTAINER_NAME="${{ steps.parse_component.outputs.name }}"
        else
           IFS='/' read -r owner repo <<< "$GITHUB_REPOSITORY"
           CONTAINER_NAME="$repo"
        fi
        echo "CONTAINER_NAME=$CONTAINER_NAME" >> "$GITHUB_OUTPUT"
        echo "CONTAINER_NAME=$CONTAINER_NAME" >> "$GITHUB_ENV"
        echo "OWNER=$(echo "$owner" | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_ENV"

    - name: Checkout Repository
      if: ${{ inputs.checkout == 'true' }}
      uses: actions/checkout@v5
      with:
        ref: ${{ inputs.ref }}

    - name: Display Debug Information
      shell: bash
      env:
        CUSTOM_IMAGE_NAME: ${{ inputs.custom-image-name }}
      run: |
        echo "custom-image-name: ${CUSTOM_IMAGE_NAME:-empty}"
        echo "env CONTAINER_NAME: ${{ env.CONTAINER_NAME }}"
        echo "env OWNER: ${{ env.OWNER }}"
        echo "ref: ${{ inputs.ref }}"
        echo "GITHUB_REPOSITORY: ${{ github.repository }}"
        echo "GITHUB_REF: ${{ github.ref }}"
        echo "URL: ghcr.io/${{ env.OWNER }}/${{ env.CONTAINER_NAME }}"

    - name: Download Artifact
      if: ${{ inputs.download-artifact == 'true' }}
      uses: actions/download-artifact@v5
      with:
        name: ${{ inputs.custom-image-name }}
        path: ${{ inputs.download-artifact-path != '' && inputs.download-artifact-path || '.' }}
        merge-multiple: ${{ inputs.download-artifact-merge-multiple == 'true' }}

    - name: Debug ls
      if: ${{ inputs.debug == 'true' }}
      shell: bash
      env:
        DL_PATH: ${{ inputs.download-artifact-path }}
        CONTEXT_DIR: ${{ steps.parse_component.outputs.ctx }}
      run: |
        echo "ðŸ” Current directory:"
        pwd
        echo "ðŸ“‚ Full workspace tree:"
        ls -R -la ${{ github.workspace }}

    - name: Check Downloaded Artifact
      if: ${{ inputs.download-artifact == 'true' }}
      shell: bash
      run: |
        echo "ðŸ” Artifact download path: ${{ inputs.download-artifact-path != '' && inputs.download-artifact-path || '..' }}"
        echo "ðŸ“‚ Checking workspace (${{ github.workspace }}):"
        ls -la ${{ github.workspace }}
        echo "ðŸ“‚ Checking for target in workspace:"
        find ${{ github.workspace }} -name "target" -type d -exec ls -la {} \; 2>/dev/null || echo "No target dir in workspace"
        echo "ðŸ“‚ Checking parent dir (${{ github.workspace }}/..):"
        ls -la ${{ github.workspace }}/.. | grep qubership-colly || echo "No qubership-colly in parent"
        echo "ðŸ“‚ Checking for target in parent:"
        find ${{ github.workspace }}/.. -name "target" -type d -exec ls -la {} \; 2>/dev/null || echo "No target dir in parent"

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ env.GITHUB_TOKEN }}

    - name: Extract Docker Metadata
      if: ${{ inputs.tags == '' }}
      id: meta
      uses: docker/metadata-action@v5
      with:
        context: ${{ inputs.context }}
        images: ghcr.io/${{ github.repository_owner }}/${{ env.CONTAINER_NAME }}
        tags: |
          type=ref,event=branch
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}

    - name: Create Image Refs (docker ghcr.io/owner/name:tag)
      if: ${{ inputs.tags != '' }}
      id: create-image-refs
      shell: bash
      env:
        TAGS_INPUT: ${{ inputs.tags }}
      run: |
        echo "Create Image Refs (docker ghcr.io/owner/name:tag)"
        CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
        REPO_OWNER="${{ env.OWNER }}"
        TAGS_INPUT="${{ inputs.tags }}"

        IFS=',' read -ra TAGS <<< "$TAGS_INPUT"

        IMAGE_REFS=""
        for TAG in "${TAGS[@]}"; do
          TAG=$(echo "$TAG" | xargs)
          IMAGE_REFS="$IMAGE_REFS,ghcr.io/$REPO_OWNER/$CONTAINER_NAME:$TAG"
        done

        IMAGE_REFS="${IMAGE_REFS#,}"
        IMAGE_REFS=$(echo "$IMAGE_REFS" | tr '[:upper:]' '[:lower:]')

        # echo "prepared_tags=$IMAGE_REFS" >> "$GITHUB_OUTPUT"
        echo "Image refs: $IMAGE_REFS"
        echo "IMAGE_REFS=$(echo "$IMAGE_REFS" | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_ENV"


    - name: Build and Push Docker Image
      uses: docker/build-push-action@v6
      id: dockerbuild
      with:
        provenance: false
        sbom: ${{ inputs.sbom == 'true' && 'true' || 'false' }}
        context: ${{ steps.parse_component.outputs.ctx }}
        file: ${{ steps.parse_component.outputs.file }}
        push: ${{ inputs.dry-run == 'true' && 'false' || 'true' }}
        tags: ${{ inputs.tags != '' && env.IMAGE_REFS || steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: ${{ inputs.platforms }}
        build-args: ${{ inputs.build-args }}

    - name: Output result
      id: output_result
      shell: bash
      run: |
        set -euo pipefail

        IMAGE_NAME_FULL=$(echo '${{ steps.dockerbuild.outputs.metadata }}' | jq -r '.["image.name"]' | cut -d',' -f1)
        IMAGE_NAME="${IMAGE_NAME_FULL%%:*}"
        TAG="${IMAGE_NAME_FULL##*:}"

        DIGEST="${{ steps.dockerbuild.outputs.digest }}"
        ALG="${DIGEST%%:*}"
        DIGEST_NO_PREFIX="${DIGEST##*:}"
        DIGEST_SHORT="${DIGEST_NO_PREFIX:0:12}"

        GROUP="${{ inputs.app-manifest-group }}"

        VERSION="$TAG"

        if command -v uuidgen >/dev/null 2>&1; then
          UUID="$(uuidgen)"
        else
          UUID="${VERSION}-0000-0000-0000-000000000000"
        fi

        BOM_REF="${IMAGE_NAME}:${UUID}"

        BASENAME=$(basename "$IMAGE_NAME")
        FILENAME="${BASENAME}-${TAG}-${DIGEST_SHORT}.json"

        echo ">>> IMAGE_NAME        = $IMAGE_NAME"
        echo ">>> DIGEST            = $DIGEST"
        echo ">>> DIGEST_SHORT(12)  = $DIGEST_SHORT"
        echo ">>> FILENAME          = $FILENAME"
        echo ">>> BOM_REF           = $BOM_REF"

        cat <<EOF > "$FILENAME"
        {
          "bom-ref": "${BOM_REF}",
          "type": "container",
          "mime-type": "application/vnd.docker.image",
          "name": "${IMAGE_NAME}",
          "group": "${GROUP}",
          "version": "${VERSION}",
          "hashes":[
            {
              "alg": "${ALG}",
              "content": "${DIGEST_NO_PREFIX}"
            }],
          "purl": "pkg:docker/core/${IMAGE_NAME}@${VERSION}?registryName=sandbox"
        }
        EOF

        echo "metadata_path=$PWD/$FILENAME" >> "$GITHUB_OUTPUT"
        echo "metadata_filename=$FILENAME" >> "$GITHUB_OUTPUT"

    - name: Analyze for critical and high CVEs
      id: docker-scout-cves
      if: ${{ inputs.security-scan == 'true' }}
      uses: docker/scout-action@v1
      continue-on-error: true
      with:
        command: cves,recommendations
        image: ${{ steps.output_result.outputs.image_name }}
        sarif-file: sarif.output.json
        summary: true
        ignore-base: false
        dockerhub-user: ${{ inputs.docker-io-user }}
        dockerhub-password: ${{ inputs.docker-io-password }}
        github-token: ${{ env.GITHUB_TOKEN }}

    - name: Upload SARIF result
      id: upload-sarif
      if: ${{ inputs.security-scan == 'true' }}
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: sarif.output.json
